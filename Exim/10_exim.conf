filter {
        date {
                locale => "en"
                match => [ "exim_date", "yyyy-MM-dd HH:mm:ss" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_RECEIVED}" }
                add_field => [ "exim_msg_state", "Received" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_LOCAL}" }
                add_field => [ "exim_msg_state", "Sent Local" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_OUT}" }
                match => { "message" => "%{EXIM_DELIVERY_DKIM_OUT}" }
                add_field => [ "exim_msg_state", "Sent Out" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_AUTOOUT}" }
                match => { "message" => "%{EXIM_DELIVERY_DKIM_AUTOOUT}" }
                add_field => [ "exim_msg_state", "Auto Reply" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_MAILMAN}" }
                add_field => [ "exim_msg_state", "Sent Mailman" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_VIA_RELAY}" }
                add_field => [ "exim_msg_state", "Sent via Relay" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_BOXTRAPPER}" }
                add_field => [ "exim_msg_state", "Sent via Boxtrapper" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_JUNK}" }
                add_field => [ "exim_msg_state", "Sent via Junk" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_CENTRAL_FILTER}" }
                add_field => [ "exim_msg_state", "Central Filter" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_USER_FILTER}" }
                add_field => [ "exim_msg_state", "User Filter" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_ROUTING_DEFER}" }
                add_field => [ "exim_msg_state", "Retry Time Not Reached" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_RETRY_DEFER}" }
                add_field => [ "exim_msg_state", "Retry Time Not Reached For Any Host" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_LOOKUP_DEFER}" }
                add_field => [ "exim_msg_state", "Host Lookup Did Not Complete" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_NOROUTE_DEFER}" }
                add_field => [ "exim_msg_state", "No Route To Host" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_RETRY_DEFER}" }
                add_field => [ "exim_msg_state", "Connection Timed Out" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_TIMEOUT_EXCEEDED}" }
                add_field => [ "exim_msg_state", "Retry Timeout Exceeded" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_HOUR_EMAILS}" }
                add_field => [ "exim_msg_state", "Exceeded Emails" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_DEFER_FAIL}" }
                add_field => [ "exim_msg_state", "Exceeded Failed" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_SENDER_SUSPENDED_OUT}" }
                add_field => [ "exim_msg_state", "Sender Suspended out" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_SMTP_ERROR}" }
                add_field => [ "exim_msg_state", "Sent Failed" ]
        }
        grok {
                patterns_dir => "/etc/logstash/patterns.d"
                match => { "message" => "%{EXIM_DELIVERY_BOUNCED}" }
                add_field => [ "exim_msg_state", "Mail Delivery Bounced" ]
        }

        mutate {
                convert => {
                      "exim_msg_size" => "integer"
                }
                rename => [
                     "exim_msgid", "Queue ID",
                     "exim_flag", "Flags",
                     "exim_msg_size", "Size",
                     "exim_remote_hostname", "Remote Hostname",
                     "exim_remote_ip", "Remote IP",
                     "exim_remote_port", "Remote Port",
                     "exim_sender", "From",
                     "exim_receiver", "To",
                     "domain_sent", "Domain Sent",
                     "domain_receive", "Domain Received",
                     "exim_code", "Code",
                     "exim_msg_state", "Status",
                     "exim_responses", "Responses"
                     ]
                remove_field => [
                     "[agent][ephemeral_id]", "[agent][hostname]", "[agent][id]", "[agent][type]", "[agent][version]", "domain", "dsn", "ecs", "host", "exim_protocol", "exim_to", "exim_subject", "exim_remote_host", "exim_remote_heloname", "exim_router", "exim_transport", "input", "log", "message", "offset", "remote_port", "user_receive", "user_sent"
                ]
                remove_tag => [ "_grokparsefailure", "beats_input_codec_plain_applied" ]
        }

        if ![Queue ID] {
        drop {}
        } else if [Flags] == "<=" and [From]{
        aggregate {
                task_id => "%{Queue ID}"
                code => "
                        map['From'] = event.get('From')
                        map['Domain Sent'] = event.get('Domain Sent')
                        map['Size'] = event.get('Size')
                        map['Remote IP'] = event.get('Remote IP')
                        "
                map_action => "create"
                }
        } else if [Flags] =~ /[-=>*]>|[*]{2}|==/ and [To]{
        aggregate {
                task_id => "%{Queue ID}"
                code => "
                        event.set('From', map['From'])
                        event.set('Domain Sent', map['Domain Sent'])
                        event.set('Size', map['Size'])
                        event.set('Remote IP', map['Remote IP'])
                        "
                map_action => "update"
                push_map_as_event_on_timeout => true
                timeout => 3600
                add_tag => [ "Aggregate"]
              }
        }

        geoip {
                source      => "Remote IP"
                target      => "geoip"
                database    => "/etc/logstash/GeoLite2-City.mmdb"
                add_field   => [ "[location]", "%{[geoip][longitude]}" ]
                add_field   => [ "[location]", "%{[geoip][latitude]}"  ]
                remove_field   => [ "geoip.continent_code" ]
                }

        mutate {
                remove_field => [
                "[geoip][real_region_name]",
                "[geoip][continent_code]",
                "[geoip][area_code]",
                "[geoip][ip]",
                "[geoip][country_code2]",
                "[geoip][country_code3]",
                "[geoip][latitude]",
                "[geoip][location.lat]",
                "[geoip][location.lon]",
                "[geoip][longitude]",
                "[geoip][timezone]",
                "[geoip][postal_code]",
                "[geoip][region_code]",
                "[geoip][region_name]",
                "[geoip][city_name]",
                "[geoip][location]",
                "location"
                ]
                rename => [
                "geoip.country_name", "country"
                ]
        }
}
