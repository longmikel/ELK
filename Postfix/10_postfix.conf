filter {
        # preformat log received from filebeat input
        grok {
            match => { "message" => "%{SYSLOGTIMESTAMP} %{SYSLOGHOST} %{DATA:program}(?:\[%{POSINT}\])?: %{GREEDYDATA:extra_field}" }
        }

        # grok log lines by program name (listed alpabetically)
        if [program] =~ /^postfix.*\/anvil$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_ANVIL}" ]
                tag_on_failure => [ "_grok_postfix_anvil_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/bounce$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_BOUNCE}" ]
                tag_on_failure => [ "_grok_postfix_bounce_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                remove_field => [ "postfix_bounce_queueid", "extra_field" ]
                remove_tag => [ "beats_input_codec_plain_applied" ]
                }
        } else if [program] =~ /^postfix.*\/cleanup$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_CLEANUP}" ]
                tag_on_failure => [ "_grok_postfix_cleanup_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/dnsblog$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_DNSBLOG}" ]
                tag_on_failure => [ "_grok_postfix_dnsblog_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/local$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_LOCAL}" ]
                tag_on_failure => [ "_grok_postfix_local_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/master$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_MASTER}" ]
                tag_on_failure => [ "_grok_postfix_master_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
                } else if [program] =~ /^postfix.*\/pickup$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_PICKUP}" ]
                tag_on_failure => [ "_grok_postfix_pickup_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/pipe$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_PIPE}" ]
                tag_on_failure => [ "_grok_postfix_pipe_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/postdrop$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_POSTDROP}" ]
                tag_on_failure => [ "_grok_postfix_postdrop_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/postscreen$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_POSTSCREEN}" ]
                tag_on_failure => [ "_grok_postfix_postscreen_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/qmgr$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_QMGR}" ]
                tag_on_failure => [ "_grok_postfix_qmgr_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                remove_field => [ "extra_field" ]
                }
        } else if [program] =~ /^postfix.*\/scache$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_SCACHE}" ]
                tag_on_failure => [ "_grok_postfix_scache_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/sendmail$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_SENDMAIL}" ]
                tag_on_failure => [ "_grok_postfix_sendmail_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
                } else if [program] =~ /^postfix.*\/smtp$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_SMTP}" ]
                tag_on_failure => [ "_grok_postfix_smtp_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                remove_field => [ "postfix_smtp_stage", "postfix_smtp_lostconn_data", "postfix_smtp_lostconn_reason", "postfix_relay_service", "postfix_size", "extra_field" ]
                remove_tag => [ "_geoip_lookup_failure", "beats_input_codec_plain_applied" ]
                }
        } else if [program] =~ /^postfix.*\/lmtp$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_LMTP}" ]
                tag_on_failure => [ "_grok_postfix_lmtp_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/smtpd$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_SMTPD}" ]
                tag_on_failure => [ "_grok_postfix_smtpd_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/tlsmgr$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_TLSMGR}" ]
                tag_on_failure => [ "_grok_postfix_tlsmgr_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/tlsproxy$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_TLSPROXY}" ]
                tag_on_failure => [ "_grok_postfix_tlsproxy_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/trivial-rewrite$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_TRIVIAL_REWRITE}" ]
                tag_on_failure => [ "_grok_postfix_trivial_rewrite_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*\/discard$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_DISCARD}" ]
                tag_on_failure => [ "_grok_postfix_discard_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
                } else if [program] =~ /^postfix.*\/virtual$/ {
            grok {
                patterns_dir   => "/etc/logstash/patterns.d"
                match          => [ "message", "%{POSTFIX_VIRTUAL}" ]
                tag_on_failure => [ "_grok_postfix_virtual_nomatch" ]
                add_tag        => [ "_grok_postfix_success" ]
                }
        } else if [program] =~ /^postfix.*/ {
            mutate {
                add_tag => [ "_grok_postfix_program_nomatch" ]
                }
        }

        # process key-value data is it exists
        if [postfix_keyvalue_data] {
            kv {
                source       => "postfix_keyvalue_data"
                trim_value         => "<>,"
                prefix       => "postfix_"
                remove_field => [ "postfix_keyvalue_data" ]
                }

            # some post processing of key-value data
            if [postfix_client] {
                grok {
                    patterns_dir   => "/etc/logstash/patterns.d"
                    match          => ["postfix_client", "%{POSTFIX_CLIENT_INFO}"]
                    tag_on_failure => [ "_grok_kv_postfix_client_nomatch" ]
                    remove_field   => [ "postfix_client" ]
                }
            }
            if [postfix_relay] {
                grok {
                    patterns_dir   => "/etc/logstash/patterns.d"
                    match          => ["postfix_relay", "%{POSTFIX_RELAY_INFO}"]
                    tag_on_failure => [ "_grok_kv_postfix_relay_nomatch" ]
                    remove_field   => [ "postfix_relay" ]
                }
            }
            if [postfix_delays] {
                grok {
                    patterns_dir   => "/etc/logstash/patterns.d"
                    match          => ["postfix_delays", "%{POSTFIX_DELAYS}"]
                    tag_on_failure => [ "_grok_kv_postfix_delays_nomatch" ]
                    remove_field => [ "postfix_delays", "postfix_delay", "postfix_delay_before_qmgr", "postfix_delay_conn_setup", "postfix_delay_in_qmgr", "postfix_delay_transmission" ]
                }
            }
        }

        date {
            match => [ "postfix_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
            target => "postfix_timestamp"
            timezone => 'Asia/Ho_Chi_Minh'
        }

        # Do some data type conversions
        mutate {
            convert => [
                "postfix_anvil_cache_size", "integer",
                "postfix_anvil_conn_count", "integer",
                "postfix_anvil_conn_rate", "integer",
                "postfix_client_port", "integer",
                "postfix_nrcpt", "integer",
                "postfix_postscreen_cache_dropped", "integer",
                "postfix_postscreen_cache_retained", "integer",
                "postfix_postscreen_dnsbl_rank", "integer",
                "postfix_relay_port", "integer",
                "postfix_server_port", "integer",
                "postfix_size", "integer",
                "postfix_status_code", "integer",
                "postfix_termination_signal", "integer",
                "postfix_uid", "integer",
                "postfix_delay", "float",
                "postfix_delay_before_qmgr", "float",
                "postfix_delay_conn_setup", "float",
                "postfix_delay_in_qmgr", "float",
                "postfix_delay_transmission", "float",
                "postfix_postscreen_violation_time", "float",
                "location", "float"
                ]
           rename => [
                "postfix_queueid", "Queue ID",
                "postfix_dsn", "dsn",
                "postfix_relay_hostname", "Relay Hostname",
                "postfix_relay_ip", "Relay IP",
                "postfix_relay_port", "Relay Port",
                "postfix_relay_service", "Relay Service",
                "postfix_from", "From",
                "postfix_to", "To",
                "postfix_size", "Size",
                "postfix_nrcpt", "NRcpt",
                "postfix_smtp_response", "Responses",
                "postfix_status", "Status"
                ]
           remove_field => [
                "@version", "agent", "beat", "host", "input", "offset", "source", "type", "message", "log", "ecs", "dsn"
                ]
        }

        if ![Queue ID] {
        drop {}
        } else if [program] =~ /^postfix.*\/qmgr$/ and [From]{
        aggregate {
                task_id => "%{Queue ID}"
                code => "
                        map['From'] = event.get('From')
                        map['Size'] = event.get('Size')
                        map['NRcpt'] = event.get('NRcpt')
                        "
                        map_action => "create"
                }
        } else if [program] =~ /^postfix.*\/smtp$/ and [To]{
        aggregate {
        task_id => "%{Queue ID}"
                code => "
                        event.set('From', map['From'])
                        event.set('Size', map['Size'])
                        event.set('NRcpt', map['NRcpt'])
                        "
                        map_action => "update"
                push_map_as_event_on_timeout => true
                timeout_task_id_field => "Queue ID"
                timeout => 3600
                inactivity_timeout => 360
                add_tag => [ "aggregate" ]
        remove_tag => [ "_grok_postfix_success" ]
                }
        }

        geoip {
                source      => "relay_ip"
                target      => "geoip"
                database    => "/etc/logstash/GeoLite2-City.mmdb"
                add_field   => [ "[location]", "%{[geoip][longitude]}" ]
                add_field   => [ "[location]", "%{[geoip][latitude]}"  ]
                remove_field   => [ "geoip.continent_code" ]
                }

        mutate {
                remove_field => [
                "[geoip][real_region_name]",
                "[geoip][continent_code]",
                "[geoip][area_code]",
                "[geoip][ip]",
                "[geoip][country_code2]",
                "[geoip][country_code3]",
                "[geoip][latitude]",
                "[geoip][location.lat]",
                "[geoip][location.lon]",
                "[geoip][longitude]",
                "[geoip][timezone]",
                "[geoip][postal_code]",
                "[geoip][region_code]",
                "[geoip][region_name]",
                "[geoip][city_name]",
                "[geoip][location]",
                "location"
                ]
                rename => [
                "geoip.country_name", "country"
                ]
        }
}
